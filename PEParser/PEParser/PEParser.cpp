#include <windows.h>
#include <stdio.h>


int main()
{
    char filePath[] = "C:\\Projects\\DetectMe.exe";

    HANDLE hFile = CreateFileA(filePath, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) 
    {
        printf("Error: Cannot open file %s\n", filePath);
        return 1;
    }
    else
    {
        BYTE dosBuffer[sizeof(IMAGE_DOS_HEADER)] = { 0, };
        BYTE ntBuffer[sizeof(IMAGE_NT_HEADERS32)] = { 0, };
        DWORD read_length = 0;

        if (ReadFile(hFile, dosBuffer, sizeof(dosBuffer), &read_length, NULL))
        {
            printf("\n[Dos Header] information(file read) :\n");
            printf("  Magic number: 0x%X\n", ((IMAGE_DOS_HEADER*)dosBuffer)->e_magic);

            if (SetFilePointer(hFile, ((IMAGE_DOS_HEADER*)dosBuffer)->e_lfanew, NULL, FILE_BEGIN) != INVALID_SET_FILE_POINTER)
            {
                if (ReadFile(hFile, ntBuffer, sizeof(IMAGE_NT_HEADERS32), &read_length, NULL))
                {
                    if (((IMAGE_NT_HEADERS32*)ntBuffer)->Signature == IMAGE_NT_SIGNATURE)
                    {
                        printf("\n[NT Header] information(file read) :\n");
                        printf("  Machine type: 0x%X\n", ((IMAGE_NT_HEADERS32*)ntBuffer)->FileHeader.Machine);
                    }
                }
            }
        }
    }

    HANDLE hMapping = CreateFileMappingA(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hMapping == NULL) 
    {
        CloseHandle(hFile);
        printf("Error: Cannot create file mapping\n"); 
        return 1;
    }

    LPVOID lpBase = MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
    if (lpBase == NULL) 
    {
        CloseHandle(hMapping);
        CloseHandle(hFile);
        printf("Error: Cannot map view of file\n");
        return 1;
    }

    IMAGE_DOS_HEADER* dosHeader = (IMAGE_DOS_HEADER*)lpBase;
    if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE)
    {
        printf("\n[Dos Header] information:\n");
        printf("  Magic number: 0x%X\n", dosHeader->e_magic);
        printf("  File address of new exe header: 0x%X\n", dosHeader->e_lfanew);
    }
    else
    {
        printf("Error: Invalid [DOS Header] signature\n");
        UnmapViewOfFile(lpBase);
        CloseHandle(hMapping);
        CloseHandle(hFile);
        return 1;
    }

    DWORD ntSignature = *((DWORD *)((BYTE*)lpBase + dosHeader->e_lfanew));
    if (ntSignature == IMAGE_NT_SIGNATURE)
    {
        WORD machineType = *((WORD *)((BYTE*)lpBase + dosHeader->e_lfanew + sizeof(DWORD)));
        if (machineType == IMAGE_FILE_MACHINE_I386)
        {
            // 32bit
            IMAGE_NT_HEADERS32* ntHeader32 = (IMAGE_NT_HEADERS32*)((BYTE*)lpBase + dosHeader->e_lfanew);
            {
                // 32bit
                printf("\n[NT Header] information:\n");
                printf("  Machine type: 0x%X\n", ntHeader32->FileHeader.Machine);
                printf("  Number of sections: 0x%X\n", (WORD)ntHeader32->FileHeader.NumberOfSections);
                printf("  Timestamp: 0x%X\n", ntHeader32->FileHeader.TimeDateStamp);
                printf("  Entry point address: 0x%X\n", ntHeader32->OptionalHeader.AddressOfEntryPoint);
                printf("  Image base address: 0x%lX\n", ntHeader32->OptionalHeader.ImageBase);
                printf("  Section alignment: 0x%X\n", ntHeader32->OptionalHeader.SectionAlignment);
                printf("  File alignment: 0x%X\n", ntHeader32->OptionalHeader.FileAlignment);
                printf("  Size of image: 0x%X\n", ntHeader32->OptionalHeader.SizeOfImage);
                printf("  Size of headers: 0x%X\n", ntHeader32->OptionalHeader.SizeOfHeaders);
                printf("  Subsystem: 0x%X\n", ntHeader32->OptionalHeader.Subsystem);
                printf("  Number of RVA and sizes: 0x%X\n", ntHeader32->OptionalHeader.NumberOfRvaAndSizes);
            }
        }
        else if (machineType == IMAGE_FILE_MACHINE_AMD64)
        {
            // 64bit
            IMAGE_NT_HEADERS64* ntHeader64 = (IMAGE_NT_HEADERS64*)((BYTE*)lpBase + dosHeader->e_lfanew);
            {
                printf("\n[NT Header] information:\n");
                printf("  Machine type: 0x%X\n", ntHeader64->FileHeader.Machine);
                printf("  Number of sections: 0x%X\n", (WORD)ntHeader64->FileHeader.NumberOfSections);
                printf("  Timestamp: 0x%X\n", ntHeader64->FileHeader.TimeDateStamp);
                printf("  Entry point address: 0x%X\n", ntHeader64->OptionalHeader.AddressOfEntryPoint);
                printf("  Image base address: 0x%I64X\n", ntHeader64->OptionalHeader.ImageBase);
                printf("  Section alignment: 0x%X\n", ntHeader64->OptionalHeader.SectionAlignment);
                printf("  File alignment: 0x%X\n", ntHeader64->OptionalHeader.FileAlignment);
                printf("  Size of image: 0x%X\n", ntHeader64->OptionalHeader.SizeOfImage);
                printf("  Size of headers: 0x%X\n", ntHeader64->OptionalHeader.SizeOfHeaders);
                printf("  Subsystem: 0x%X\n", ntHeader64->OptionalHeader.Subsystem);
                printf("  Number of RVA and sizes: 0x%X\n", ntHeader64->OptionalHeader.NumberOfRvaAndSizes);
            }
        }
        else
        {
            printf("Error: Unknown machine\n");
            UnmapViewOfFile(lpBase);
            CloseHandle(hMapping);
            CloseHandle(hFile);
            return 1;
        }
    }
    else
    {
        printf("Error: Invalid [NT Header] signature\n");
        UnmapViewOfFile(lpBase);
        CloseHandle(hMapping);
        CloseHandle(hFile);
        return 1;
    }

    UnmapViewOfFile(lpBase);
    CloseHandle(hMapping);
    CloseHandle(hFile);

    return 0;
}
